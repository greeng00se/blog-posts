> Real MySQL 8.0을 읽고 정리한 글입니다.
> 

## 인덱스

- 칼럼의 값과 해당 레코드가 저장된 주소를 `key-value` 형태로 만들어 일종의 목차를 만드는 것이다.
- 데이터의 저장 (`INSERT`, `UPDATE`, `DELETE`) 성능이 줄어들지만 조희(`SELECT`)의 성능을 향상시킨다.

```sql
-- 인덱스 조회
SHOW INDEX FROM table_name;

-- 인덱스 생성
CREATE INDEX index_key_name ON table_name (column_name);
ALTER TABLE table_name ADD INDEX index_key_name (column_name);

-- 인덱스 삭제
ALTER TABLE table_name DROP INDEX idx_pname;

-- 실제로 인덱스가 사용되는지 확인 (Type -> All & possible_keys	-> NULL 이면 사용되지 않는 것)
EXPLAIN
select * from table_name
where column_name = '조회할 것';
```

- UNIQUE 옵션을 이용해 UNIQUE 인덱스를 생성할 수 있다.

### 역할에 따른 인덱스 분류

- 프라이머리키와 보조키로 구분할 수 있다.
- 프라이머리 키
    - 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미한다.
    - 식별할 수 있는 기준 값이 되고, 식별자라고 부른다.
    - `NULL` 값과 중복을 허용하지 않는다.
- 보조 키(세컨더리 인덱스)
    - 프라이머리 키를 제외한 모든 인덱스는 세컨더리 인덱스로 분류한다.

### 알고리즘에 따른 분류

- 인덱스에는 다양한 알고리즘이 사용되지만 대표적으로 두 가지로 구분할 수 있다.
- B-Tree 알고리즘
    - 칼럼의 값을 변형하지 않고 원래의 값으 이용해 인덱싱하는 알고리즘이다.
- Hash 인덱스 알고리즘
    - 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘이다.
    - 값을 변형하기 때문에 Prefix를 조회하는 경우 사용할 수 없다.
    

### 데이터의 중복 허용 여부에 따른 분류

- 유니크 인덱스와 유니크하지 않은 인덱스로 구분할 수 있다.
- 유니크 인덱스에 대해 동등조건(=) 검색은 항상 1건의 코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에 알리는 효과를 가진다.

## 참고 자료

- [CREATE INDEX Statement, MySQL](https://dev.mysql.com/doc/refman/8.0/en/create-index.html)