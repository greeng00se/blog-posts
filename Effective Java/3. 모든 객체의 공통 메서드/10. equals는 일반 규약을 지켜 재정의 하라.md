> Joshua Bloch님의 Effective Java 3/E를 읽고 정리한 글입니다.
> 

## equals는 일반 규약을 지켜 재정의 하라

- `Object.equals()` 메서드는 비교하는 두 객체의 주소 값을 비교하여 boolean을 반환한다.
- `equals()` 메서드를 재정의 할 필요가 없는 경우와, 재정의 해야되는 경우, 재정의시 고려할 점을 알아보자

## 재정의가 필요없는 경우

- 다음 상황 중 하나에 해당된다면 재정의하지 않는 것이 최선이다.

### 1. 각각의 인스턴스가 고유할 경우

- 값보단 동작하는 개체를 표현하는 클래스가 이 경우에 해당된다.
    - 예) `java.lang.Thread` 클래스

### 2. 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없는 경우

- `equals()` 메서드를 재정의해서 논리적 동치성을 확인할 수 있는 방법을 제공하는 클래스를 만들 수 있다.
- 클래스를 정의할 때 논리적 동치성이 필요없다고 생각한다면, 기본 `equals()` 메서드로 충분하다.

### 3. 상위 클래스에서 재정의한 equals가 하위 클래스에도 적합한 경우

- `Collections` 프레임워크의 구현체들은 Abstract 클래스가 존재하고 이미 재정의된 `equals()`를 상속받아 사용한다.

```java
public boolean equals(Object o) {
    if (o == this)
        return true;
    if (!(o instanceof List))
        return false;

    ListIterator<E> e1 = listIterator();
    ListIterator<?> e2 = ((List<?>) o).listIterator();
    while (e1.hasNext() && e2.hasNext()) {
        E o1 = e1.next();
        Object o2 = e2.next();
        if (!(o1==null ? o2==null : o1.equals(o2)))
            return false;
    }
    return !(e1.hasNext() || e2.hasNext());
}
```

- ArrayList가 사용하는 `AbstractList.equals(Object o)`

### 4. 클래스가 private이거나 package-private이고 equals를 호출할 일이 없는 경우

- 의도하지 않은 `equals()` 메서드 호출을 막고싶으면 다음과 같이 구현하면 된다.

```java
@Override
public boolean equals(Object obj) {
    throw new AssertionError();
}
```

### 5. 값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 경우

- 같은 값을 생성하지 않도록 설정한 클래스의 경우 `Object.equals()` 가 논리적 동치성까지 확인해준다.

## 재정의가 필요한 경우

### 객체 식별성이 아닌 논리적 동치성을 확인해야 하는 경우

- 상위 클래스의 `equals()` 메서드가 논리적 동치성을 비교하도록 재정의 되지 않았을 경우
- `Integer`, `String` 처럼 값을 표현하는 클래스들이 여기 해당된다.
- 논리적 동치성을 확인할 수 있도록 재정의 한다면 값을 비교하거나, `Map`의 키, `Set`의 원소로 사용할 수 있다.

> 📌 객체 식별성(object identity)
> 
> - 같은 상태를 가지고 있어도 구별할 수 있는지의 여부

## 재정의 시 지켜야하는 규약

- `Object.equals()` 메서드의 명세에는 동치관계를 구현한다고 되어있다.
- Object 명세에서 말하는 동치 관계란?
    - 집합을 서로 같은 원소들로 이루어진 부분집합으로 나누는 연산
- equals 규약을 어긴다면, 규약을 어긴 객체를 사용하는 다른 객체의 동작을 예측할 수 없다.

### 반사성(reflexivity)

- `null`이 아닌 모든 참조 값 x에 대해, `x.equlas(x)`는 참이다.
- 객체는 자기 자신과 같아야 한다
- 반사성을 만족하지 못하는 클래스가 있다면, 해당 클래스의 인스턴스를 컬렉션에 넣은 후 `contains()` 메서드를 호출하여 인스턴스의 존재 유무를 확인할 때 해당 인스턴스가 없다고 나올 것이다.

### 대칭성(symmetry)

- `null`이 아닌 모든 참조 값 x, y에 대해, `x.equals(y)`의 결과와 `y.equals(x)`의 결과가 동일하다.
- 두 객체가 있을 때 서로의 동치 여부에 대해 같은 결과를 반환해야된다.
- 대칭성이 성립하지 않는 경우에 대해 알아보자

```java
public class CaseInsensitiveString {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s);
    }

    @Override
    public boolean equals(Object o) {
        if (o instanceof CaseInsensitiveString) {
            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
        }
        if (o instanceof String) {
            return s.equalsIgnoreCase((String) o);
        }
        return false;
    }
}
```

- 책의 예제로 문자열을 필드로 가지고 있고, 문자열의 대소문자를 구분하지 않는 클래스다.
- `equals()` 메서드를 재정의 하였고, 일반 문자열과도 비교를 시도할 수 있다.

```java
@Test
void violationSymmetry() {
    CaseInsensitiveString cis = new CaseInsensitiveString("Korean");
    String s = "Korean";

    assertThat(cis.equals(s)).isTrue();
    assertThat(s.equals(cis)).isFalse();
}
```

- CaseInsensitiveString 클래스는 String 클래스의 존재를 알고 있지만 그 반대는 다르다.
- 이렇게 대칭성이 성립되지 않는 경우에는 한 쪽을 포기하거나, 반대 편을 맞춰줘야 한다.

### 추이성(transitivity)

- `null`이 아닌 모든 참조 값 x, y, z에 대해, `x.equals(y)`가 true고 `y.equals(z)`가 true면 `x.equals(z)`도 true다.
- 일반적인 형태의 삼단논법과 비슷하다.
- 구체 클래스를 확장하여 새로운 값을 추가하면서 equals 규약을 만족하는 방법은 존재하지 않는다.