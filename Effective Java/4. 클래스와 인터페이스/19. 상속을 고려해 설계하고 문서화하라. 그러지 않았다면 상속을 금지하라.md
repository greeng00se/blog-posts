> Joshua Bloch님의 Effective Java 3/E를 읽고 정리한 글입니다.
> 

## 상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라

- 상속을 고려하면서 클래스를 설계하는 방법을 알아보자

## 상속용 클래스가 지켜야할 규약

### 1. 상속을 고려하여 문서화를 하라

- 내부 메커니즘을 문서화하라
    - 재정의 가능한 메서드들은 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다.
- 문서에는 다음과 같은 내용을 담아야 한다.
    - 호출하는 메서드의 내용과 호출 순서
    - 호출 결과가 이어지는 처리에 주는 영향
- 좋은 API 문서란 ‘어떻게'가 아닌 ‘무엇’을 하는지를 설명해야 하지만, 안전하게 상속할 수 있도록 하려면 내부구현 방식을 설명해야만 한다.

### 2. 클래스의 내부 동작 과정 중간에 끼어들 수 있는 훅 메서드를 선별하여 protected 메서드 형태로 공개해야 할 수도 있다.

- 효율적인 하위 클래스를 큰 어려움 없이 만들게 할 수 있다.
    - 동작과정을 다르게 하여 성능이 향상되게 만들 수 있다.
- `protected` 메서드는 내부 구현에 해당하므로 공개해야하는 메서드 수가 적을 수록 좋다.

![image](https://user-images.githubusercontent.com/58586537/171857088-30dc9d2c-dc93-47fa-bc89-39381df1eb16.png)

- `protected`로 공개한 `AbstractList.removeRange()`
    - 리스트 구현의 내부 구조를 활용하도록 정의하면 성능 개선을 할 수 있다고 문서화 되어있다.

### 3. 상속용으로 설계한 클래스는 배포 전에 반드시 하위 클래스를 만들어 검증하라

- 필요한 메서드를 `protected`로 선언하지 않았다면, 하위 클래스를 작성할 때 빈자리가 확연히 드러난다.
- 검증을 위한 하위 클래스는 3개 정도가 적당하고, 하나 정도는 제 3자가 작성하는 것이 좋다.

### 4. 상속용 클래스의 생성자는 재정의 가능 메서드를 호출해서는 안된다.

- 프로그램이 오동작할 수 있다.
- 상위 클래스의 생성자가 하위 클래스의 생성자보다 먼저 실행되므로, 하위 클래스에서 재정의한 메서드가 하위 클래스의 생성자보다 우선적으로 호출된다.
- `private`, `final`, `static` 메서드는 재정의가 불가능하니 생성자에서 호출해도 문제 없다.

```java
public class Super {

    public Super() {
        overrideMe();
    }

    public void overrideMe() {
    }
}

public final class Sub extends Super {

    private final Instant instant;

    public Sub() {
        this.instant = Instant.now();
    }

    @Override
    public void overrideMe() {
        System.out.println(instant);
    }

    public static void main(String[] args) {
        Sub sub = new Sub(); // null
        sub.overrideMe(); // 2022-06-03T06:17:36.917541Z
    }
}
```

- 책에서 나온 예시처럼 하위 클래스의 생성자가 인스턴스 필드를 초기화하기 전에 재정의한 메서드를 호출해서 `null`을 출력한다.
- 재정의한 메서드가 초기화하지 않은 인스턴스 필드의 메서드를 호출시킨다면 `NPE`가 발생할 수 있다.

### 5. clone과 readObject 모두 재정의 가능 메서드를 호출해서는 안된다.

- `Cloneable`과 `Serializable` 인터페이스는 상속용 설계를 더 복잡하게 만든다.
- 복제에 사용되는 `clone()`, 직렬화에 사용되는 `readObject()` 메서드는 생성자와 비슷한 효과를 가진다.
- 그렇기 때문에 규약 4번과 같이 재정의 가능한 메서드를 호출할 경우 문제가 발생할 수 있다.
- `Serializable`을 구현한 상속용 클래스가 직렬화시 자동으로 호출되는 `readResolve`나 `writeReplace` 메서드를 가진다면, `protected`로 선언해야 한다.
    - 규약 2번에 해당된다. `private`으로 선언한다면 하위 클래스에서 무시된다.

## 상속을 고려하지 않은 클래스의 상속

- 상속용으로 설계되지 않은 클래스는 상속을 못하도록 해야한다.
- 클래스가 핵심 기능을 가진 인터페이스를 구현한 경우 상속을 금지해도 개발하는데 큰 문제가 되지 않는다.

### 상속을 금지하는 방법

- 클래스를 `final`로 선언한다.
- 모든 생성자를 `private`이나 `package-private`으로 선언하고 `public` 정적 팩터리를 생성한다.

### 예외 상황

- 클래스가 표준 인터페이스를 구현하지 않은 경우 재정의 가능 메서드를 호출하는 자기 사용 코드를 제거하고 사용하면 상속해도 위험성이 줄어든다.
- 재정의 가능 메서드를 사용하는 코드를 제거하는 순서는 다음과 같다.
    - 본문 코드를 `private` 도우미 메서드로 옮기고, 도우미 메서드를 호출하도록 한다.
    - 재정의 가능 메서드를 호출하는 다른 코드들을 모두 이 도우미 메서드를 직접 호출하도록 수정한다.

## 정리

- 상속용으로 설계되지 않은 클래스는 상속하지 말아라
- 클래스를 확장해야 할 명확한 이유가 없으면 상속을 금지하자.