# 61. 박싱된 기본 타입보다는 기본타입을 사용하라

## 박싱된 기본 타입보다는 기본타입을 사용하라

- 자바 타입은은 기본 타입과 참조 타입으로 나뉘고 기본타입에 대응하는 박싱된 기본타입이 있다.
- 어떤 상황에서 기본타입을 사용해야하는지 알아보자.

### 기본 타입과 박싱된 기본 타입의 차이

- 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값 + 식별성이란 속성을 가진다.
    - 값이 같더라도 참조값으로 비교가될 수 있다.
- 기본 타입은 값이 언제나 유효하지만, 박싱된 기본 타입은 null을 가질 수 있다.
- 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용에서 효율적이다.

### == 연산자 사용시 발생하는 문제

```java
Comparator<Integer> naturalOrder = (i, j) -> (i < j) ? -1 : (i == j ? 0 : 1);
```

- 첫번째 검사인 < 연산자의 경우 의도한대로 값을 비교하도록 동작한다.
- 두번째 검사인 == 연산자를 사용할 때 객체 참조에 대한 식별성을 검사한다.
- 박싱된 기본 타입에 == 연산자를 사용하는 경우 의도한 대로 동작하지 않을 수 있다.
- 다음과 같이 언박싱을 한 후에 사용해야 한다.

```java
Comparator<Integer> naturalOrder = (iBoxed, jBoxed) -> {
    int i = iBoxed, j = jBoxed;
    return (i < j) ? -1 : (i == j ? 0 : 1);
};
```

### 기본 타입과 박싱된 기본타입을 혼용하여 사용할 때 발생하는 문제

```java
public class Unbelievable {

    static Integer i;

    public static void main(String[] args) {
        if (i == 42) {
            System.out.println("믿을 수 없네");
        }
    }
}
```

- 기본타입과 박싱된 기본타입의 연산을 하는 경우 박싱이 자동으로 풀리게 된다.
- 위 경우 초기화하지 않은 `Integer` 변수가 박싱이 풀리게 되면서 `NullPointerException`이 발생한다.

### 계속 박싱과 언박싱이 반복되는 문제

```java
@Test
void autoBoxingTest() {
    Long sum = 0L;

    for (long i = 0; i < Integer.MAX_VALUE; i++) {
        sum += i;
    }

    System.out.println(sum);
}
```

- 위 코드는 기본 타입의 연산을 하면서 박싱이 풀리게되고 연산 결과를 박싱을 하여 참조 타입에 저장한다.
- 언박싱과 박싱이 반복되면서 성능상 문제가 생긴다.

### 박싱된 기본 타입은 언제 사용해야하는가?

- 컬렉션의 원소, 키 값
    - 컬렉션은 기본 타입을 담을 수 없다.
- 제네릭을 사용하는 경우
- 리플렉션을 통해 메서드를 호출하는 경우

## 정리

- 오토박싱과 언박싱은 기본타입을 사용할 때 수고를 덜어준다.
- 기본타입을 사용할 수 있는 상황인 경우 기본타입을 사용하는 것이 좋은 것 같다.