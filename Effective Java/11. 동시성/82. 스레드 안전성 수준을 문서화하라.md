> Joshua Bloch님의 Effective Java 3/E를 읽고 정리한 글입니다.
> 

## 스레드 안전성 수준을 문서화하라

- 클라이언트 입장에서 사용하는 API의 스레드 안전성 수준에 관련된 문서화가 안되어 있다면 멀티스레드 환경에서 과도하거나, 부족한 동기화 상태 되어 오류가 발생할 수도 있다.
- 멀티스레드 환경에서도 API를 안전하게 사용하게 하려면 클래스가 지원하는 스레드 안전성 수준을 명시해야 한다.

### 스레드 안전성 수준

- 불변(immutable)
    - 외부 동기화가 필요없고 상수와 동일.
    - 예) `String`, `Long`, `BigInteger`
- 무조건적 스레드 안전(unconditionally thread-safe)
    - 인스턴스가 수정될 수 있으나 별도의 외부 동기화가 없이도 안전하다.
    - 예) `AtomicLong`, `ConcurrentHashMap`
- 조건부 스레드 안전(conditionally thread-safe)
    - 무조건적 스레드 안전과 같으나, 일부 메서드는 외부 동기화가 필요하다.
    - 예) `Collections.synchronized` 래퍼 메서드가 반환한 컬렉션
- 스레드 안전하지 않음(not thread-safe)
    - 인스턴스가 수정될 수 있고, 동시에 사용하려면 외부 동기화 메커니즘으로 감싸야 한다.
    - 예) `ArrayList`, `HashMap`
- 스레드 적대적(thread-hostile)
    - 외부 동기화를 하더라도 멀티스레드 환경에서 안전하지 않다.
    - 사용하지 말아야 한다.

### 스레드 안전성 문서화

- 보통 클래스의 문서화 주석에 기재한다.
- 독특한 특성을 가진 메서드가 있다면 메서드 수준에서 문서화한다.

### 외부에서 사용할 수 있는 락 제공

- 클라이언트에서 제공하는 락을 가지고 동기화를 할 수 있지만 다음과 같은 문제가 발생한다.
    - 내부의 고성능 동시성 제어 메커니즘과 혼용할 수 없게 된다.
    - 락을 오랫동안 쥐고 놓지 않는 Dos 공격을 수행할 수 도 있다.
- 비공개 락 객체를 제공함으로써 Dos 공격을 예방할 수 있다.
    - 비공개 락 객체 관용구는 무조건적 스레드 안전 클래스에만 사용가능하다.
    - 조건부 스레드 안전 클래스의 경우 특정 호출 순서에 따라 얻어야 하는 락이 다를 수도 있기 때문에 사용할 수 없다.

```java
private final Object lock = new Object();

public void foo() {
    synchronized(lock) {
        ...
    }
}
```

## 정리

- 클래스를 작성할 때는 스레드 안전성에 관한 정보를 명확하게 문서화해야 한다.
- 조건부 스레드 안전 클래스의 경우 메서드의 호출 순서, 외부 동기화, 어떠한 락을 얻어야하는지 명시해야 한다.
- 무조건적 스레드 안전 클래스의 경우 비공개 락 객체를 사용하여 클라이언트나 하위 클래스에서 동기화 매커니즘을 깨뜨리는 걸 예방할 수 있다.